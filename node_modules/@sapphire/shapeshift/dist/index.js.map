{"version":3,"sources":["../src/index.ts","../src/lib/Result.ts","../src/validators/BaseValidator.ts","../src/lib/errors/ExpectedConstraintError.ts","../src/lib/errors/BaseError.ts","../src/lib/errors/BaseConstraintError.ts","../src/constraints/util/operators.ts","../src/constraints/ArrayLengthConstraints.ts","../src/lib/errors/CombinedPropertyError.ts","../src/lib/errors/ValidationError.ts","../src/validators/ArrayValidator.ts","../src/constraints/BigIntConstraints.ts","../src/validators/BigIntValidator.ts","../src/constraints/BooleanConstraints.ts","../src/validators/BooleanValidator.ts","../src/constraints/DateConstraints.ts","../src/validators/DateValidator.ts","../src/lib/errors/ExpectedValidationError.ts","../src/validators/InstanceValidator.ts","../src/validators/LiteralValidator.ts","../src/validators/NeverValidator.ts","../src/validators/NullishValidator.ts","../src/constraints/NumberConstraints.ts","../src/validators/NumberValidator.ts","../src/lib/errors/MissingPropertyError.ts","../src/lib/errors/UnknownPropertyError.ts","../src/validators/ObjectValidator.ts","../src/validators/PassthroughValidator.ts","../src/validators/RecordValidator.ts","../src/lib/errors/CombinedError.ts","../src/validators/SetValidator.ts","../src/constraints/StringConstraints.ts","../src/constraints/util/emailValidator.ts","../src/lib/errors/MultiplePossibilitiesConstraintError.ts","../src/constraints/util/common/combinedResultFn.ts","../src/constraints/util/urlValidators.ts","../src/validators/StringValidator.ts","../src/validators/TupleValidator.ts","../src/validators/UnionValidator.ts","../src/validators/MapValidator.ts","../src/validators/util/getValue.ts","../src/validators/DefaultValidator.ts","../src/lib/errors/UnknownEnumValueError.ts","../src/validators/NativeEnumValidator.ts","../src/constraints/TypedArrayLengthConstraints.ts","../src/constraints/util/typedArray.ts","../src/constraints/util/common/vowels.ts","../src/validators/TypedArrayValidator.ts","../src/lib/Shapes.ts"],"sourcesContent":["import { Shapes } from './lib/Shapes';\n\nexport const s = new Shapes();\n\nexport * from './lib/errors/BaseError';\nexport * from './lib/errors/CombinedError';\nexport * from './lib/errors/CombinedPropertyError';\nexport * from './lib/errors/ExpectedConstraintError';\nexport * from './lib/errors/ExpectedValidationError';\nexport * from './lib/errors/MissingPropertyError';\nexport * from './lib/errors/MultiplePossibilitiesConstraintError';\nexport * from './lib/errors/UnknownEnumValueError';\nexport * from './lib/errors/UnknownPropertyError';\nexport * from './lib/errors/ValidationError';\nexport * from './lib/Result';\nexport * from './type-exports';\n","export class Result<T, E extends Error = Error> {\n\tpublic readonly success: boolean;\n\tpublic readonly value?: T;\n\tpublic readonly error?: E;\n\n\tprivate constructor(success: boolean, value?: T, error?: E) {\n\t\tthis.success = success;\n\t\tif (success) {\n\t\t\tthis.value = value;\n\t\t} else {\n\t\t\tthis.error = error;\n\t\t}\n\t}\n\n\tpublic isOk(): this is { success: true; value: T } {\n\t\treturn this.success;\n\t}\n\n\tpublic isErr(): this is { success: false; error: E } {\n\t\treturn !this.success;\n\t}\n\n\tpublic unwrap(): T {\n\t\tif (this.isOk()) return this.value;\n\t\tthrow this.error as Error;\n\t}\n\n\tpublic static ok<T, E extends Error = Error>(value: T): Result<T, E> {\n\t\treturn new Result<T, E>(true, value);\n\t}\n\n\tpublic static err<T, E extends Error = Error>(error: E): Result<T, E> {\n\t\treturn new Result<T, E>(false, undefined, error);\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport type { CombinedError } from '../lib/errors/CombinedError';\nimport type { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport type { UnknownEnumValueError } from '../lib/errors/UnknownEnumValueError';\nimport type { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { ArrayValidator, DefaultValidator, LiteralValidator, NullishValidator, SetValidator, UnionValidator } from './imports';\n\nexport abstract class BaseValidator<T> {\n\tprotected constraints: readonly IConstraint<T>[] = [];\n\n\tpublic constructor(constraints: readonly IConstraint<T>[] = []) {\n\t\tthis.constraints = constraints;\n\t}\n\n\tpublic get optional(): UnionValidator<T | undefined> {\n\t\treturn new UnionValidator([new LiteralValidator(undefined), this.clone()]);\n\t}\n\n\tpublic get nullable(): UnionValidator<T | null> {\n\t\treturn new UnionValidator([new LiteralValidator(null), this.clone()]);\n\t}\n\n\tpublic get nullish(): UnionValidator<T | null | undefined> {\n\t\treturn new UnionValidator([new NullishValidator(), this.clone()]);\n\t}\n\n\tpublic get array(): ArrayValidator<T> {\n\t\treturn new ArrayValidator<T>(this.clone());\n\t}\n\n\tpublic get set(): SetValidator<T> {\n\t\treturn new SetValidator<T>(this.clone());\n\t}\n\n\tpublic or<O>(...predicates: readonly BaseValidator<O>[]): UnionValidator<T | O> {\n\t\treturn new UnionValidator<T | O>([this.clone(), ...predicates]);\n\t}\n\n\tpublic transform(cb: (value: T) => T): this;\n\tpublic transform<O>(cb: (value: T) => O): BaseValidator<O>;\n\tpublic transform<O>(cb: (value: T) => O): BaseValidator<O> {\n\t\treturn this.addConstraint({ run: (input) => Result.ok(cb(input) as unknown as T) }) as unknown as BaseValidator<O>;\n\t}\n\n\tpublic default(value: Exclude<T, undefined> | (() => Exclude<T, undefined>)): DefaultValidator<Exclude<T, undefined>> {\n\t\treturn new DefaultValidator(this.clone() as unknown as BaseValidator<Exclude<T, undefined>>, value);\n\t}\n\n\tpublic run(value: unknown): Result<T, BaseError> {\n\t\tlet result = this.handle(value) as Result<T, BaseError>;\n\t\tif (result.isErr()) return result;\n\n\t\tfor (const constraint of this.constraints) {\n\t\t\tresult = constraint.run(result.value as T);\n\t\t\tif (result.isErr()) break;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic parse(value: unknown): T {\n\t\treturn this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());\n\t}\n\n\tprotected clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.constraints]);\n\t}\n\n\tprotected abstract handle(value: unknown): Result<T, ValidatorError>;\n\n\tprotected addConstraint(constraint: IConstraint<T>): this {\n\t\tconst clone = this.clone();\n\t\tclone.constraints = clone.constraints.concat(constraint);\n\t\treturn clone;\n\t}\n}\n\nexport type ValidatorError = ValidationError | CombinedError | CombinedPropertyError | UnknownEnumValueError;\n","import { inspect, type InspectOptionsStylized } from 'node:util';\nimport { customInspectSymbolStackLess } from './BaseError';\nimport { BaseConstraintError, type ConstraintErrorNames } from './BaseConstraintError';\n\nexport class ExpectedConstraintError<T = unknown> extends BaseConstraintError<T> {\n\tpublic readonly expected: string;\n\n\tpublic constructor(constraint: ConstraintErrorNames, message: string, given: T, expected: string) {\n\t\tsuper(constraint, message, given);\n\t\tthis.expected = expected;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tconstraint: this.constraint,\n\t\t\tgiven: this.given,\n\t\t\texpected: this.expected\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst constraint = options.stylize(this.constraint, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[ExpectedConstraintError: ${constraint}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1 };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst given = inspect(this.given, newOptions).replaceAll('\\n', padding);\n\n\t\tconst header = `${options.stylize('ExpectedConstraintError', 'special')} > ${constraint}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst expectedBlock = `\\n  ${options.stylize('Expected: ', 'string')}${options.stylize(this.expected, 'boolean')}`;\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${expectedBlock}\\n${givenBlock}`;\n\t}\n}\n","import type { InspectOptionsStylized } from 'node:util';\n\nexport const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');\nexport const customInspectSymbolStackLess = Symbol.for('nodejs.util.inspect.custom.stack-less');\n\nexport abstract class BaseError extends Error {\n\tprotected [customInspectSymbol](depth: number, options: InspectOptionsStylized) {\n\t\treturn `${this[customInspectSymbolStackLess](depth, options)}\\n${this.stack!.slice(this.stack!.indexOf('\\n'))}`;\n\t}\n\n\tprotected abstract [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string;\n}\n","import type {\n\tArrayConstraintName,\n\tBigIntConstraintName,\n\tBooleanConstraintName,\n\tDateConstraintName,\n\tNumberConstraintName,\n\tStringConstraintName,\n\tTypedArrayConstraintName\n} from '../../constraints/type-exports';\nimport { BaseError } from './BaseError';\n\nexport type ConstraintErrorNames =\n\t| TypedArrayConstraintName\n\t| ArrayConstraintName\n\t| BigIntConstraintName\n\t| BooleanConstraintName\n\t| DateConstraintName\n\t| NumberConstraintName\n\t| StringConstraintName;\n\nexport abstract class BaseConstraintError<T = unknown> extends BaseError {\n\tpublic readonly constraint: ConstraintErrorNames;\n\tpublic readonly given: T;\n\n\tpublic constructor(constraint: ConstraintErrorNames, message: string, given: T) {\n\t\tsuper(message);\n\t\tthis.constraint = constraint;\n\t\tthis.given = given;\n\t}\n}\n","export function lt(a: number, b: number): boolean;\nexport function lt(a: bigint, b: bigint): boolean;\nexport function lt(a: number | bigint, b: number | bigint): boolean {\n\treturn a < b;\n}\n\nexport function le(a: number, b: number): boolean;\nexport function le(a: bigint, b: bigint): boolean;\nexport function le(a: number | bigint, b: number | bigint): boolean {\n\treturn a <= b;\n}\n\nexport function gt(a: number, b: number): boolean;\nexport function gt(a: bigint, b: bigint): boolean;\nexport function gt(a: number | bigint, b: number | bigint): boolean {\n\treturn a > b;\n}\n\nexport function ge(a: number, b: number): boolean;\nexport function ge(a: bigint, b: bigint): boolean;\nexport function ge(a: number | bigint, b: number | bigint): boolean {\n\treturn a >= b;\n}\n\nexport function eq(a: number, b: number): boolean;\nexport function eq(a: bigint, b: bigint): boolean;\nexport function eq(a: number | bigint, b: number | bigint): boolean {\n\treturn a === b;\n}\n\nexport function ne(a: number, b: number): boolean;\nexport function ne(a: bigint, b: bigint): boolean;\nexport function ne(a: number | bigint, b: number | bigint): boolean {\n\treturn a !== b;\n}\n\nexport interface Comparator {\n\t(a: number, b: number): boolean;\n\t(a: bigint, b: bigint): boolean;\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { Comparator, eq, ge, gt, le, lt, ne } from './util/operators';\n\nexport type ArrayConstraintName = `s.array(T).length${'Lt' | 'Le' | 'Gt' | 'Ge' | 'Eq' | 'Ne' | 'Range' | 'RangeInclusive' | 'RangeExclusive'}`;\n\nfunction arrayLengthComparator<T>(comparator: Comparator, name: ArrayConstraintName, expected: string, length: number): IConstraint<T[]> {\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn comparator(input.length, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function arrayLengthLt<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length < ${value}`;\n\treturn arrayLengthComparator(lt, 's.array(T).lengthLt', expected, value);\n}\n\nexport function arrayLengthLe<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length <= ${value}`;\n\treturn arrayLengthComparator(le, 's.array(T).lengthLe', expected, value);\n}\n\nexport function arrayLengthGt<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length > ${value}`;\n\treturn arrayLengthComparator(gt, 's.array(T).lengthGt', expected, value);\n}\n\nexport function arrayLengthGe<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length >= ${value}`;\n\treturn arrayLengthComparator(ge, 's.array(T).lengthGe', expected, value);\n}\n\nexport function arrayLengthEq<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length === ${value}`;\n\treturn arrayLengthComparator(eq, 's.array(T).lengthEq', expected, value);\n}\n\nexport function arrayLengthNe<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length !== ${value}`;\n\treturn arrayLengthComparator(ne, 's.array(T).lengthNe', expected, value);\n}\n\nexport function arrayLengthRange<T>(start: number, endBefore: number): IConstraint<T[]> {\n\tconst expected = `expected.length >= ${start} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn input.length >= start && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).lengthRange', 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function arrayLengthRangeInclusive<T>(start: number, end: number): IConstraint<T[]> {\n\tconst expected = `expected.length >= ${start} && expected.length <= ${end}`;\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn input.length >= start && input.length <= end //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).lengthRangeInclusive', 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function arrayLengthRangeExclusive<T>(startAfter: number, endBefore: number): IConstraint<T[]> {\n\tconst expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn input.length > startAfter && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).lengthRangeExclusive', 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n","import type { InspectOptionsStylized } from 'node:util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class CombinedPropertyError extends BaseError {\n\tpublic readonly errors: [PropertyKey, BaseError][];\n\n\tpublic constructor(errors: [PropertyKey, BaseError][]) {\n\t\tsuper('Received one or more errors');\n\n\t\tthis.errors = errors;\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize('[CombinedPropertyError]', 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\n\t\tconst header = `${options.stylize('CombinedPropertyError', 'special')} (${options.stylize(this.errors.length.toString(), 'number')})`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst errors = this.errors\n\t\t\t.map(([key, error]) => {\n\t\t\t\tconst property = CombinedPropertyError.formatProperty(key, options);\n\t\t\t\tconst body = error[customInspectSymbolStackLess](depth - 1, newOptions).replaceAll('\\n', padding);\n\n\t\t\t\treturn `  input${property}${padding}${body}`;\n\t\t\t})\n\t\t\t.join('\\n\\n');\n\t\treturn `${header}\\n  ${message}\\n\\n${errors}`;\n\t}\n\n\tprivate static formatProperty(key: PropertyKey, options: InspectOptionsStylized): string {\n\t\tif (typeof key === 'string') return options.stylize(`.${key}`, 'symbol');\n\t\tif (typeof key === 'number') return `[${options.stylize(key.toString(), 'number')}]`;\n\t\treturn `[${options.stylize('Symbol', 'symbol')}(${key.description})]`;\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'node:util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class ValidationError extends BaseError {\n\tpublic readonly validator: string;\n\tpublic readonly given: unknown;\n\n\tpublic constructor(validator: string, message: string, given: unknown) {\n\t\tsuper(message);\n\n\t\tthis.validator = validator;\n\t\tthis.given = given;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvalidator: this.validator,\n\t\t\tgiven: this.given\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst validator = options.stylize(this.validator, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[ValidationError: ${validator}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst given = inspect(this.given, newOptions).replaceAll('\\n', padding);\n\n\t\tconst header = `${options.stylize('ValidationError', 'special')} > ${validator}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${givenBlock}`;\n\t}\n}\n","import {\n\tarrayLengthEq,\n\tarrayLengthGe,\n\tarrayLengthGt,\n\tarrayLengthLe,\n\tarrayLengthLt,\n\tarrayLengthNe,\n\tarrayLengthRange,\n\tarrayLengthRangeExclusive,\n\tarrayLengthRangeInclusive\n} from '../constraints/ArrayLengthConstraints';\nimport type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class ArrayValidator<T> extends BaseValidator<T[]> {\n\tprivate readonly validator: BaseValidator<T>;\n\n\tpublic constructor(validator: BaseValidator<T>, constraints: readonly IConstraint<T[]>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tpublic lengthLt<N extends number>(length: N): BaseValidator<ExpandSmallerTuples<UnshiftTuple<[...Tuple<T, N>]>>> {\n\t\treturn this.addConstraint(arrayLengthLt(length) as IConstraint<T[]>) as any;\n\t}\n\n\tpublic lengthLe<N extends number>(length: N): BaseValidator<ExpandSmallerTuples<[...Tuple<T, N>]>> {\n\t\treturn this.addConstraint(arrayLengthLe(length)) as any;\n\t}\n\n\tpublic lengthGt<N extends number>(length: N): BaseValidator<[...Tuple<T, N>, T, ...T[]]> {\n\t\treturn this.addConstraint(arrayLengthGt(length)) as any;\n\t}\n\n\tpublic lengthGe<N extends number>(length: N): BaseValidator<[...Tuple<T, N>, ...T[]]> {\n\t\treturn this.addConstraint(arrayLengthGe(length)) as any;\n\t}\n\n\tpublic lengthEq<N extends number>(length: N): BaseValidator<[...Tuple<T, N>]> {\n\t\treturn this.addConstraint(arrayLengthEq(length)) as any;\n\t}\n\n\tpublic lengthNe(length: number): BaseValidator<[...T[]]> {\n\t\treturn this.addConstraint(arrayLengthNe(length)) as any;\n\t}\n\n\tpublic lengthRange<S extends number, E extends number>(\n\t\tstart: S,\n\t\tendBefore: E\n\t): BaseValidator<Exclude<ExpandSmallerTuples<UnshiftTuple<[...Tuple<T, E>]>>, ExpandSmallerTuples<UnshiftTuple<[...Tuple<T, S>]>>>> {\n\t\treturn this.addConstraint(arrayLengthRange(start, endBefore)) as any;\n\t}\n\n\tpublic lengthRangeInclusive<S extends number, E extends number>(\n\t\tstartAt: S,\n\t\tendAt: E\n\t): BaseValidator<Exclude<ExpandSmallerTuples<[...Tuple<T, E>]>, ExpandSmallerTuples<UnshiftTuple<[...Tuple<T, S>]>>>> {\n\t\treturn this.addConstraint(arrayLengthRangeInclusive(startAt, endAt)) as any;\n\t}\n\n\tpublic lengthRangeExclusive<S extends number, E extends number>(\n\t\tstartAfter: S,\n\t\tendBefore: E\n\t): BaseValidator<Exclude<ExpandSmallerTuples<UnshiftTuple<[...Tuple<T, E>]>>, ExpandSmallerTuples<[...Tuple<T, S>]>>> {\n\t\treturn this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore)) as any;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<T[], ValidationError | CombinedPropertyError> {\n\t\tif (!Array.isArray(values)) {\n\t\t\treturn Result.err(new ValidationError('s.array(T)', 'Expected an array', values));\n\t\t}\n\n\t\tconst errors: [number, BaseError][] = [];\n\t\tconst transformed: T[] = [];\n\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst result = this.validator.run(values[i]);\n\t\t\tif (result.isOk()) transformed.push(result.value);\n\t\t\telse errors.push([i, result.error!]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n\nexport type UnshiftTuple<T extends [...any[]]> = T extends [T[0], ...infer Tail] ? Tail : never;\nexport type ExpandSmallerTuples<T extends [...any[]]> = T extends [T[0], ...infer Tail] ? T | ExpandSmallerTuples<Tail> : [];\n\n// https://github.com/microsoft/TypeScript/issues/26223#issuecomment-755067958\nexport type Shift<A extends Array<any>> = ((...args: A) => void) extends (...args: [A[0], ...infer R]) => void ? R : never;\n\nexport type GrowExpRev<A extends Array<any>, N extends number, P extends Array<Array<any>>> = A['length'] extends N\n\t? A\n\t: GrowExpRev<[...A, ...P[0]][N] extends undefined ? [...A, ...P[0]] : A, N, Shift<P>>;\n\nexport type GrowExp<A extends Array<any>, N extends number, P extends Array<Array<any>>> = [...A, ...A][N] extends undefined\n\t? GrowExp<[...A, ...A], N, [A, ...P]>\n\t: GrowExpRev<A, N, P>;\n\nexport type Tuple<T, N extends number> = number extends N ? Array<T> : N extends 0 ? [] : N extends 1 ? [T] : GrowExp<[T], N, [[]]>;\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { Comparator, eq, ge, gt, le, lt, ne } from './util/operators';\n\nexport type BigIntConstraintName = `s.bigint.${'lt' | 'le' | 'gt' | 'ge' | 'eq' | 'ne' | 'divisibleBy'}`;\n\nfunction bigintComparator(comparator: Comparator, name: BigIntConstraintName, expected: string, number: bigint): IConstraint<bigint> {\n\treturn {\n\t\trun(input: bigint) {\n\t\t\treturn comparator(input, number) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid bigint value', input, expected));\n\t\t}\n\t};\n}\n\nexport function bigintLt(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected < ${value}n`;\n\treturn bigintComparator(lt, 's.bigint.lt', expected, value);\n}\n\nexport function bigintLe(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected <= ${value}n`;\n\treturn bigintComparator(le, 's.bigint.le', expected, value);\n}\n\nexport function bigintGt(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected > ${value}n`;\n\treturn bigintComparator(gt, 's.bigint.gt', expected, value);\n}\n\nexport function bigintGe(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected >= ${value}n`;\n\treturn bigintComparator(ge, 's.bigint.ge', expected, value);\n}\n\nexport function bigintEq(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected === ${value}n`;\n\treturn bigintComparator(eq, 's.bigint.eq', expected, value);\n}\n\nexport function bigintNe(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected !== ${value}n`;\n\treturn bigintComparator(ne, 's.bigint.ne', expected, value);\n}\n\nexport function bigintDivisibleBy(divider: bigint): IConstraint<bigint> {\n\tconst expected = `expected % ${divider}n === 0n`;\n\treturn {\n\t\trun(input: bigint) {\n\t\t\treturn input % divider === 0n //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.bigint.divisibleBy', 'BigInt is not divisible', input, expected));\n\t\t}\n\t};\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { bigintDivisibleBy, bigintEq, bigintGe, bigintGt, bigintLe, bigintLt, bigintNe } from '../constraints/BigIntConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class BigIntValidator<T extends bigint> extends BaseValidator<T> {\n\tpublic lt(number: bigint): this {\n\t\treturn this.addConstraint(bigintLt(number) as IConstraint<T>);\n\t}\n\n\tpublic le(number: bigint): this {\n\t\treturn this.addConstraint(bigintLe(number) as IConstraint<T>);\n\t}\n\n\tpublic gt(number: bigint): this {\n\t\treturn this.addConstraint(bigintGt(number) as IConstraint<T>);\n\t}\n\n\tpublic ge(number: bigint): this {\n\t\treturn this.addConstraint(bigintGe(number) as IConstraint<T>);\n\t}\n\n\tpublic eq<N extends bigint>(number: N): BigIntValidator<N> {\n\t\treturn this.addConstraint(bigintEq(number) as IConstraint<T>) as unknown as BigIntValidator<N>;\n\t}\n\n\tpublic ne(number: bigint): this {\n\t\treturn this.addConstraint(bigintNe(number) as IConstraint<T>);\n\t}\n\n\tpublic get positive(): this {\n\t\treturn this.ge(0n);\n\t}\n\n\tpublic get negative(): this {\n\t\treturn this.lt(0n);\n\t}\n\n\tpublic divisibleBy(number: bigint): this {\n\t\treturn this.addConstraint(bigintDivisibleBy(number) as IConstraint<T>);\n\t}\n\n\tpublic get abs(): this {\n\t\treturn this.transform((value) => (value < 0 ? -value : value) as T);\n\t}\n\n\tpublic intN(bits: number): this {\n\t\treturn this.transform((value) => BigInt.asIntN(bits, value) as T);\n\t}\n\n\tpublic uintN(bits: number): this {\n\t\treturn this.transform((value) => BigInt.asUintN(bits, value) as T);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'bigint' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.bigint', 'Expected a bigint primitive', value));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\n\nexport type BooleanConstraintName = `s.boolean.${boolean}`;\n\nexport const booleanTrue: IConstraint<boolean, true> = {\n\trun(input: boolean) {\n\t\treturn input //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.boolean.true', 'Invalid boolean value', input, 'true'));\n\t}\n};\n\nexport const booleanFalse: IConstraint<boolean, false> = {\n\trun(input: boolean) {\n\t\treturn input //\n\t\t\t? Result.err(new ExpectedConstraintError('s.boolean.false', 'Invalid boolean value', input, 'false'))\n\t\t\t: Result.ok(input);\n\t}\n};\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { booleanFalse, booleanTrue } from '../constraints/BooleanConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class BooleanValidator<T extends boolean = boolean> extends BaseValidator<T> {\n\tpublic get true(): BooleanValidator<true> {\n\t\treturn this.addConstraint(booleanTrue as IConstraint<T>) as BooleanValidator<true>;\n\t}\n\n\tpublic get false(): BooleanValidator<false> {\n\t\treturn this.addConstraint(booleanFalse as IConstraint<T>) as BooleanValidator<false>;\n\t}\n\n\tpublic eq<R extends true | false>(value: R): BooleanValidator<R> {\n\t\treturn (value ? this.true : this.false) as BooleanValidator<R>;\n\t}\n\n\tpublic ne<R extends true | false>(value: R): BooleanValidator<R> {\n\t\treturn (value ? this.false : this.true) as BooleanValidator<R>;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'boolean' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.boolean', 'Expected a boolean primitive', value));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { Comparator, eq, ge, gt, le, lt, ne } from './util/operators';\n\nexport type DateConstraintName = `s.date.${'lt' | 'le' | 'gt' | 'ge' | 'eq' | 'ne' | 'valid' | 'invalid'}`;\n\nfunction dateComparator(comparator: Comparator, name: DateConstraintName, expected: string, number: number): IConstraint<Date> {\n\treturn {\n\t\trun(input: Date) {\n\t\t\treturn comparator(input.getTime(), number) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Date value', input, expected));\n\t\t}\n\t};\n}\n\nexport function dateLt(value: Date): IConstraint<Date> {\n\tconst expected = `expected < ${value.toISOString()}`;\n\treturn dateComparator(lt, 's.date.lt', expected, value.getTime());\n}\n\nexport function dateLe(value: Date): IConstraint<Date> {\n\tconst expected = `expected <= ${value.toISOString()}`;\n\treturn dateComparator(le, 's.date.le', expected, value.getTime());\n}\n\nexport function dateGt(value: Date): IConstraint<Date> {\n\tconst expected = `expected > ${value.toISOString()}`;\n\treturn dateComparator(gt, 's.date.gt', expected, value.getTime());\n}\n\nexport function dateGe(value: Date): IConstraint<Date> {\n\tconst expected = `expected >= ${value.toISOString()}`;\n\treturn dateComparator(ge, 's.date.ge', expected, value.getTime());\n}\n\nexport function dateEq(value: Date): IConstraint<Date> {\n\tconst expected = `expected === ${value.toISOString()}`;\n\treturn dateComparator(eq, 's.date.eq', expected, value.getTime());\n}\n\nexport function dateNe(value: Date): IConstraint<Date> {\n\tconst expected = `expected !== ${value.toISOString()}`;\n\treturn dateComparator(ne, 's.date.ne', expected, value.getTime());\n}\n\nexport const dateInvalid: IConstraint<Date> = {\n\trun(input: Date) {\n\t\treturn Number.isNaN(input.getTime()) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.date.invalid', 'Invalid Date value', input, 'expected === NaN'));\n\t}\n};\n\nexport const dateValid: IConstraint<Date> = {\n\trun(input: Date) {\n\t\treturn Number.isNaN(input.getTime()) //\n\t\t\t? Result.err(new ExpectedConstraintError('s.date.valid', 'Invalid Date value', input, 'expected !== NaN'))\n\t\t\t: Result.ok(input);\n\t}\n};\n","import { dateEq, dateGe, dateGt, dateInvalid, dateLe, dateLt, dateNe, dateValid } from '../constraints/DateConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class DateValidator extends BaseValidator<Date> {\n\tpublic lt(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateLt(new Date(date)));\n\t}\n\n\tpublic le(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateLe(new Date(date)));\n\t}\n\n\tpublic gt(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateGt(new Date(date)));\n\t}\n\n\tpublic ge(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateGe(new Date(date)));\n\t}\n\n\tpublic eq(date: Date | number | string): this {\n\t\tconst resolved = new Date(date);\n\t\treturn Number.isNaN(resolved.getTime()) //\n\t\t\t? this.invalid\n\t\t\t: this.addConstraint(dateEq(resolved));\n\t}\n\n\tpublic ne(date: Date | number | string): this {\n\t\tconst resolved = new Date(date);\n\t\treturn Number.isNaN(resolved.getTime()) //\n\t\t\t? this.valid\n\t\t\t: this.addConstraint(dateNe(resolved));\n\t}\n\n\tpublic get valid(): this {\n\t\treturn this.addConstraint(dateValid);\n\t}\n\n\tpublic get invalid(): this {\n\t\treturn this.addConstraint(dateInvalid);\n\t}\n\n\tprotected handle(value: unknown): Result<Date, ValidationError> {\n\t\treturn value instanceof Date //\n\t\t\t? Result.ok(value)\n\t\t\t: Result.err(new ValidationError('s.date', 'Expected a Date', value));\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'node:util';\nimport { customInspectSymbolStackLess } from './BaseError';\nimport { ValidationError } from './ValidationError';\n\nexport class ExpectedValidationError<T> extends ValidationError {\n\tpublic readonly expected: T;\n\n\tpublic constructor(validator: string, message: string, given: unknown, expected: T) {\n\t\tsuper(validator, message, given);\n\t\tthis.expected = expected;\n\t}\n\n\tpublic override toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvalidator: this.validator,\n\t\t\tgiven: this.given,\n\t\t\texpected: this.expected\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst validator = options.stylize(this.validator, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[ExpectedValidationError: ${validator}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1 };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst expected = inspect(this.expected, newOptions).replaceAll('\\n', padding);\n\t\tconst given = inspect(this.given, newOptions).replaceAll('\\n', padding);\n\n\t\tconst header = `${options.stylize('ExpectedValidationError', 'special')} > ${validator}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst expectedBlock = `\\n  ${options.stylize('Expected:', 'string')}${padding}${expected}`;\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${expectedBlock}\\n${givenBlock}`;\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { ExpectedValidationError } from '../lib/errors/ExpectedValidationError';\nimport { Result } from '../lib/Result';\nimport type { Constructor } from '../lib/util-types';\nimport { BaseValidator } from './imports';\n\nexport class InstanceValidator<T> extends BaseValidator<T> {\n\tpublic readonly expected: Constructor<T>;\n\n\tpublic constructor(expected: Constructor<T>, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.expected = expected;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ExpectedValidationError<Constructor<T>>> {\n\t\treturn value instanceof this.expected //\n\t\t\t? Result.ok(value)\n\t\t\t: Result.err(new ExpectedValidationError('s.instance(V)', 'Expected', value, this.expected));\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.expected, this.constraints]);\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { ExpectedValidationError } from '../lib/errors/ExpectedValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class LiteralValidator<T> extends BaseValidator<T> {\n\tpublic readonly expected: T;\n\n\tpublic constructor(literal: T, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.expected = literal;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ExpectedValidationError<T>> {\n\t\treturn Object.is(value, this.expected) //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ExpectedValidationError('s.literal(V)', 'Expected values to be equals', value, this.expected));\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.expected, this.constraints]);\n\t}\n}\n","import { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NeverValidator extends BaseValidator<never> {\n\tprotected handle(value: unknown): Result<never, ValidationError> {\n\t\treturn Result.err(new ValidationError('s.never', 'Expected a value to not be passed', value));\n\t}\n}\n","import { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NullishValidator extends BaseValidator<undefined | null> {\n\tprotected handle(value: unknown): Result<undefined | null, ValidationError> {\n\t\treturn value === undefined || value === null //\n\t\t\t? Result.ok(value)\n\t\t\t: Result.err(new ValidationError('s.nullish', 'Expected undefined or null', value));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { Comparator, eq, ge, gt, le, lt, ne } from './util/operators';\n\nexport type NumberConstraintName = `s.number.${\n\t| 'lt'\n\t| 'le'\n\t| 'gt'\n\t| 'ge'\n\t| 'eq'\n\t| 'eq(NaN)'\n\t| 'ne'\n\t| 'ne(NaN)'\n\t| 'int'\n\t| 'safeInt'\n\t| 'finite'\n\t| 'divisibleBy'}`;\n\nfunction numberComparator(comparator: Comparator, name: NumberConstraintName, expected: string, number: number): IConstraint<number> {\n\treturn {\n\t\trun(input: number) {\n\t\t\treturn comparator(input, number) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid number value', input, expected));\n\t\t}\n\t};\n}\n\nexport function numberLt(value: number): IConstraint<number> {\n\tconst expected = `expected < ${value}`;\n\treturn numberComparator(lt, 's.number.lt', expected, value);\n}\n\nexport function numberLe(value: number): IConstraint<number> {\n\tconst expected = `expected <= ${value}`;\n\treturn numberComparator(le, 's.number.le', expected, value);\n}\n\nexport function numberGt(value: number): IConstraint<number> {\n\tconst expected = `expected > ${value}`;\n\treturn numberComparator(gt, 's.number.gt', expected, value);\n}\n\nexport function numberGe(value: number): IConstraint<number> {\n\tconst expected = `expected >= ${value}`;\n\treturn numberComparator(ge, 's.number.ge', expected, value);\n}\n\nexport function numberEq(value: number): IConstraint<number> {\n\tconst expected = `expected === ${value}`;\n\treturn numberComparator(eq, 's.number.eq', expected, value);\n}\n\nexport function numberNe(value: number): IConstraint<number> {\n\tconst expected = `expected !== ${value}`;\n\treturn numberComparator(ne, 's.number.ne', expected, value);\n}\n\nexport const numberInt: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isInteger(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(\n\t\t\t\t\tnew ExpectedConstraintError('s.number.int', 'Given value is not an integer', input, 'Number.isInteger(expected) to be true')\n\t\t\t  );\n\t}\n};\n\nexport const numberSafeInt: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isSafeInteger(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(\n\t\t\t\t\tnew ExpectedConstraintError(\n\t\t\t\t\t\t's.number.safeInt',\n\t\t\t\t\t\t'Given value is not a safe integer',\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\t'Number.isSafeInteger(expected) to be true'\n\t\t\t\t\t)\n\t\t\t  );\n\t}\n};\n\nexport const numberFinite: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isFinite(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.number.finite', 'Given value is not finite', input, 'Number.isFinite(expected) to be true'));\n\t}\n};\n\nexport const numberNaN: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isNaN(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.number.eq(NaN)', 'Invalid number value', input, 'expected === NaN'));\n\t}\n};\n\nexport const numberNeNaN: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isNaN(input) //\n\t\t\t? Result.err(new ExpectedConstraintError('s.number.ne(NaN)', 'Invalid number value', input, 'expected !== NaN'))\n\t\t\t: Result.ok(input);\n\t}\n};\n\nexport function numberDivisibleBy(divider: number): IConstraint<number> {\n\tconst expected = `expected % ${divider} === 0`;\n\treturn {\n\t\trun(input: number) {\n\t\t\treturn input % divider === 0 //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.number.divisibleBy', 'Number is not divisible', input, expected));\n\t\t}\n\t};\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport {\n\tnumberDivisibleBy,\n\tnumberEq,\n\tnumberFinite,\n\tnumberGe,\n\tnumberGt,\n\tnumberInt,\n\tnumberLe,\n\tnumberLt,\n\tnumberNaN,\n\tnumberNe,\n\tnumberNeNaN,\n\tnumberSafeInt\n} from '../constraints/NumberConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NumberValidator<T extends number> extends BaseValidator<T> {\n\tpublic lt(number: number): this {\n\t\treturn this.addConstraint(numberLt(number) as IConstraint<T>);\n\t}\n\n\tpublic le(number: number): this {\n\t\treturn this.addConstraint(numberLe(number) as IConstraint<T>);\n\t}\n\n\tpublic gt(number: number): this {\n\t\treturn this.addConstraint(numberGt(number) as IConstraint<T>);\n\t}\n\n\tpublic ge(number: number): this {\n\t\treturn this.addConstraint(numberGe(number) as IConstraint<T>);\n\t}\n\n\tpublic eq<N extends number>(number: N): NumberValidator<N> {\n\t\treturn Number.isNaN(number) //\n\t\t\t? (this.addConstraint(numberNaN as IConstraint<T>) as unknown as NumberValidator<N>)\n\t\t\t: (this.addConstraint(numberEq(number) as IConstraint<T>) as unknown as NumberValidator<N>);\n\t}\n\n\tpublic ne(number: number): this {\n\t\treturn Number.isNaN(number) //\n\t\t\t? this.addConstraint(numberNeNaN as IConstraint<T>)\n\t\t\t: this.addConstraint(numberNe(number) as IConstraint<T>);\n\t}\n\n\tpublic get int(): this {\n\t\treturn this.addConstraint(numberInt as IConstraint<T>);\n\t}\n\n\tpublic get safeInt(): this {\n\t\treturn this.addConstraint(numberSafeInt as IConstraint<T>);\n\t}\n\n\tpublic get finite(): this {\n\t\treturn this.addConstraint(numberFinite as IConstraint<T>);\n\t}\n\n\tpublic get positive(): this {\n\t\treturn this.ge(0);\n\t}\n\n\tpublic get negative(): this {\n\t\treturn this.lt(0);\n\t}\n\n\tpublic divisibleBy(divider: number): this {\n\t\treturn this.addConstraint(numberDivisibleBy(divider) as IConstraint<T>);\n\t}\n\n\tpublic get abs(): this {\n\t\treturn this.transform(Math.abs as (value: number) => T);\n\t}\n\n\tpublic get sign(): this {\n\t\treturn this.transform(Math.sign as (value: number) => T);\n\t}\n\n\tpublic get trunc(): this {\n\t\treturn this.transform(Math.trunc as (value: number) => T);\n\t}\n\n\tpublic get floor(): this {\n\t\treturn this.transform(Math.floor as (value: number) => T);\n\t}\n\n\tpublic get fround(): this {\n\t\treturn this.transform(Math.fround as (value: number) => T);\n\t}\n\n\tpublic get round(): this {\n\t\treturn this.transform(Math.round as (value: number) => T);\n\t}\n\n\tpublic get ceil(): this {\n\t\treturn this.transform(Math.ceil as (value: number) => T);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'number' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.number', 'Expected a number primitive', value));\n\t}\n}\n","import type { InspectOptionsStylized } from 'node:util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class MissingPropertyError extends BaseError {\n\tpublic readonly property: PropertyKey;\n\n\tpublic constructor(property: PropertyKey) {\n\t\tsuper('A required property is missing');\n\t\tthis.property = property;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tproperty: this.property\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst property = options.stylize(this.property.toString(), 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[MissingPropertyError: ${property}]`, 'special');\n\t\t}\n\n\t\tconst header = `${options.stylize('MissingPropertyError', 'special')} > ${property}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\treturn `${header}\\n  ${message}`;\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'node:util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class UnknownPropertyError extends BaseError {\n\tpublic readonly property: PropertyKey;\n\tpublic readonly value: unknown;\n\n\tpublic constructor(property: PropertyKey, value: unknown) {\n\t\tsuper('Received unexpected property');\n\n\t\tthis.property = property;\n\t\tthis.value = value;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tproperty: this.property,\n\t\t\tvalue: this.value\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst property = options.stylize(this.property.toString(), 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[UnknownPropertyError: ${property}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst given = inspect(this.value, newOptions).replaceAll('\\n', padding);\n\n\t\tconst header = `${options.stylize('UnknownPropertyError', 'special')} > ${property}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${givenBlock}`;\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { MissingPropertyError } from '../lib/errors/MissingPropertyError';\nimport { UnknownPropertyError } from '../lib/errors/UnknownPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport type { MappedObjectValidator, NonNullObject } from '../lib/util-types';\nimport { BaseValidator } from './BaseValidator';\n\nexport class ObjectValidator<T extends NonNullObject> extends BaseValidator<T> {\n\tpublic readonly shape: MappedObjectValidator<T>;\n\tpublic readonly strategy: ObjectValidatorStrategy;\n\tprivate readonly keys: readonly (keyof T)[];\n\tprivate readonly handleStrategy: (value: NonNullObject) => Result<T, CombinedPropertyError>;\n\n\tpublic constructor(\n\t\tshape: MappedObjectValidator<T>,\n\t\tstrategy: ObjectValidatorStrategy = ObjectValidatorStrategy.Ignore,\n\t\tconstraints: readonly IConstraint<T>[] = []\n\t) {\n\t\tsuper(constraints);\n\t\tthis.shape = shape;\n\t\tthis.keys = Object.keys(shape) as (keyof T)[];\n\t\tthis.strategy = strategy;\n\n\t\tswitch (this.strategy) {\n\t\t\tcase ObjectValidatorStrategy.Ignore:\n\t\t\t\tthis.handleStrategy = (value) => this.handleIgnoreStrategy(value);\n\t\t\t\tbreak;\n\t\t\tcase ObjectValidatorStrategy.Strict: {\n\t\t\t\tthis.handleStrategy = (value) => this.handleStrictStrategy(value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ObjectValidatorStrategy.Passthrough:\n\t\t\t\tthis.handleStrategy = (value) => this.handlePassthroughStrategy(value);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic get strict(): ObjectValidator<{ [Key in keyof T]-?: T[Key] }> {\n\t\treturn Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Strict, this.constraints]);\n\t}\n\n\tpublic get ignore(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Ignore, this.constraints]);\n\t}\n\n\tpublic get passthrough(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Passthrough, this.constraints]);\n\t}\n\n\tpublic get partial(): ObjectValidator<{ [Key in keyof T]?: T[Key] }> {\n\t\tconst shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic extend<ET extends NonNullObject>(schema: ObjectValidator<ET> | MappedObjectValidator<ET>): ObjectValidator<T & ET> {\n\t\tconst shape = { ...this.shape, ...(schema instanceof ObjectValidator ? schema.shape : schema) };\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic pick<K extends keyof T>(keys: readonly K[]): ObjectValidator<{ [Key in keyof Pick<T, K>]: T[Key] }> {\n\t\tconst shape = Object.fromEntries(keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]]));\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic omit<K extends keyof T>(keys: readonly K[]): ObjectValidator<{ [Key in keyof Omit<T, K>]: T[Key] }> {\n\t\tconst shape = Object.fromEntries(this.keys.filter((key) => !keys.includes(key as any)).map((key) => [key, this.shape[key]]));\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tprotected override handle(value: unknown): Result<T, ValidationError | CombinedPropertyError> {\n\t\tconst typeOfValue = typeof value;\n\t\tif (typeOfValue !== 'object') {\n\t\t\treturn Result.err(new ValidationError('s.object(T)', `Expected the value to be an object, but received ${typeOfValue} instead`, value));\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn Result.err(new ValidationError('s.object(T)', 'Expected the value to not be null', value));\n\t\t}\n\n\t\treturn this.handleStrategy(value as NonNullObject);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);\n\t}\n\n\tprivate handleIgnoreStrategy(value: NonNullObject, errors: [PropertyKey, BaseError][] = []): Result<T, CombinedPropertyError> {\n\t\tconst entries = {} as T;\n\t\tlet i = this.keys.length;\n\n\t\twhile (i--) {\n\t\t\tconst key = this.keys[i];\n\t\t\tconst result = this.shape[key].run(value[key as keyof NonNullObject]);\n\n\t\t\tif (result.isOk()) {\n\t\t\t\tentries[key] = result.value;\n\t\t\t} else {\n\t\t\t\tconst error = result.error!;\n\t\t\t\tif (error instanceof ValidationError && error.given === undefined) {\n\t\t\t\t\terrors.push([key, new MissingPropertyError(key)]);\n\t\t\t\t} else {\n\t\t\t\t\terrors.push([key, error]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(entries)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n\n\tprivate handleStrictStrategy(value: NonNullObject): Result<T, CombinedPropertyError> {\n\t\tconst errors: [PropertyKey, BaseError][] = [];\n\t\tconst finalResult = {} as T;\n\t\tconst keysToIterateOver = [...new Set([...Object.keys(value), ...this.keys])].reverse();\n\t\tlet i = keysToIterateOver.length;\n\n\t\twhile (i--) {\n\t\t\tconst key = keysToIterateOver[i] as string;\n\n\t\t\tif (Object.prototype.hasOwnProperty.call(this.shape, key)) {\n\t\t\t\tconst result = this.shape[key as keyof MappedObjectValidator<T>].run(value[key as keyof NonNullObject]);\n\n\t\t\t\tif (result.isOk()) {\n\t\t\t\t\tfinalResult[key as keyof T] = result.value;\n\t\t\t\t} else {\n\t\t\t\t\tconst error = result.error!;\n\t\t\t\t\tif (error instanceof ValidationError && error.given === undefined) {\n\t\t\t\t\t\terrors.push([key, new MissingPropertyError(key)]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push([key, error]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terrors.push([key, new UnknownPropertyError(key, value[key as keyof NonNullObject])]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(finalResult)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n\n\tprivate handlePassthroughStrategy(value: NonNullObject): Result<T, CombinedPropertyError> {\n\t\tconst result = this.handleIgnoreStrategy(value);\n\t\treturn result.isErr() ? result : Result.ok({ ...value, ...result.value } as T);\n\t}\n}\n\nexport const enum ObjectValidatorStrategy {\n\tIgnore,\n\tStrict,\n\tPassthrough\n}\n","import type { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class PassthroughValidator<T extends any | unknown> extends BaseValidator<T> {\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn Result.ok(value as T);\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class RecordValidator<T> extends BaseValidator<Record<string, T>> {\n\tprivate readonly validator: BaseValidator<T>;\n\n\tpublic constructor(validator: BaseValidator<T>, constraints: readonly IConstraint<Record<string, T>>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<Record<string, T>, ValidationError | CombinedPropertyError> {\n\t\tif (typeof value !== 'object') {\n\t\t\treturn Result.err(new ValidationError('s.record(T)', 'Expected an object', value));\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn Result.err(new ValidationError('s.record(T)', 'Expected the value to not be null', value));\n\t\t}\n\n\t\tconst errors: [string, BaseError][] = [];\n\t\tconst transformed: Record<string, T> = {};\n\n\t\tfor (const [key, val] of Object.entries(value!)) {\n\t\t\tconst result = this.validator.run(val);\n\t\t\tif (result.isOk()) transformed[key] = result.value;\n\t\t\telse errors.push([key, result.error!]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","import type { InspectOptionsStylized } from 'node:util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class CombinedError extends BaseError {\n\tpublic readonly errors: readonly BaseError[];\n\n\tpublic constructor(errors: readonly BaseError[]) {\n\t\tsuper('Received one or more errors');\n\n\t\tthis.errors = errors;\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize('[CombinedError]', 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\n\t\tconst header = `${options.stylize('CombinedError', 'special')} (${options.stylize(this.errors.length.toString(), 'number')})`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst errors = this.errors\n\t\t\t.map((error, i) => {\n\t\t\t\tconst index = options.stylize((i + 1).toString(), 'number');\n\t\t\t\tconst body = error[customInspectSymbolStackLess](depth - 1, newOptions).replaceAll('\\n', padding);\n\n\t\t\t\treturn `  ${index} ${body}`;\n\t\t\t})\n\t\t\t.join('\\n\\n');\n\t\treturn `${header}\\n  ${message}\\n\\n${errors}`;\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedError } from '../lib/errors/CombinedError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class SetValidator<T> extends BaseValidator<Set<T>> {\n\tprivate readonly validator: BaseValidator<T>;\n\n\tpublic constructor(validator: BaseValidator<T>, constraints: readonly IConstraint<Set<T>>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<Set<T>, ValidationError | CombinedError> {\n\t\tif (!(values instanceof Set)) {\n\t\t\treturn Result.err(new ValidationError('s.set(T)', 'Expected a set', values));\n\t\t}\n\n\t\tconst errors: BaseError[] = [];\n\t\tconst transformed = new Set<T>();\n\n\t\tfor (const value of values) {\n\t\t\tconst result = this.validator.run(value);\n\t\t\tif (result.isOk()) transformed.add(result.value);\n\t\t\telse errors.push(result.error!);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedError(errors));\n\t}\n}\n","import { isIP, isIPv4, isIPv6 } from 'node:net';\nimport { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { validateEmail } from './util/emailValidator';\nimport { Comparator, eq, ge, gt, le, lt, ne } from './util/operators';\nimport { createUrlValidators } from './util/urlValidators';\n\nexport type StringConstraintName =\n\t| `s.string.${`length${'Lt' | 'Le' | 'Gt' | 'Ge' | 'Eq' | 'Ne'}` | 'regex' | 'url' | 'uuid' | 'email' | `ip${'v4' | 'v6' | ''}`}`;\n\nexport type StringProtocol = `${string}:`;\n\nexport type StringDomain = `${string}.${string}`;\n\nexport interface UrlOptions {\n\tallowedProtocols?: StringProtocol[];\n\tallowedDomains?: StringDomain[];\n}\n\nexport type UUIDVersion = 1 | 3 | 4 | 5;\n\nexport interface StringUuidOptions {\n\tversion?: UUIDVersion | `${UUIDVersion}-${UUIDVersion}` | null;\n\tnullable?: boolean;\n}\n\nfunction stringLengthComparator(comparator: Comparator, name: StringConstraintName, expected: string, length: number): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn comparator(input.length, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid string length', input, expected));\n\t\t}\n\t};\n}\n\nexport function stringLengthLt(length: number): IConstraint<string> {\n\tconst expected = `expected.length < ${length}`;\n\treturn stringLengthComparator(lt, 's.string.lengthLt', expected, length);\n}\n\nexport function stringLengthLe(length: number): IConstraint<string> {\n\tconst expected = `expected.length <= ${length}`;\n\treturn stringLengthComparator(le, 's.string.lengthLe', expected, length);\n}\n\nexport function stringLengthGt(length: number): IConstraint<string> {\n\tconst expected = `expected.length > ${length}`;\n\treturn stringLengthComparator(gt, 's.string.lengthGt', expected, length);\n}\n\nexport function stringLengthGe(length: number): IConstraint<string> {\n\tconst expected = `expected.length >= ${length}`;\n\treturn stringLengthComparator(ge, 's.string.lengthGe', expected, length);\n}\n\nexport function stringLengthEq(length: number): IConstraint<string> {\n\tconst expected = `expected.length === ${length}`;\n\treturn stringLengthComparator(eq, 's.string.lengthEq', expected, length);\n}\n\nexport function stringLengthNe(length: number): IConstraint<string> {\n\tconst expected = `expected.length !== ${length}`;\n\treturn stringLengthComparator(ne, 's.string.lengthNe', expected, length);\n}\n\nexport function stringEmail(): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn validateEmail(input)\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.string.email', 'Invalid email address', input, 'expected to be an email address'));\n\t\t}\n\t};\n}\n\nfunction stringRegexValidator(type: StringConstraintName, expected: string, regex: RegExp): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn regex.test(input) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(type, 'Invalid string format', input, expected));\n\t\t}\n\t};\n}\n\nexport function stringUrl(options?: UrlOptions): IConstraint<string> {\n\tconst validatorFn = createUrlValidators(options);\n\treturn {\n\t\trun(input: string) {\n\t\t\tlet url: URL;\n\t\t\ttry {\n\t\t\t\turl = new URL(input);\n\t\t\t} catch {\n\t\t\t\treturn Result.err(new ExpectedConstraintError('s.string.url', 'Invalid URL', input, 'expected to match an URL'));\n\t\t\t}\n\n\t\t\tconst validatorFnResult = validatorFn(input, url);\n\t\t\tif (validatorFnResult === null) return Result.ok(input);\n\t\t\treturn Result.err(validatorFnResult);\n\t\t}\n\t};\n}\n\nexport function stringIp(version?: 4 | 6): IConstraint<string> {\n\tconst ipVersion = version ? (`v${version}` as const) : '';\n\tconst validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;\n\n\tconst name = `s.string.ip${ipVersion}` as const;\n\tconst message = `Invalid IP${ipVersion} address`;\n\tconst expected = `expected to be an IP${ipVersion} address`;\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));\n\t\t}\n\t};\n}\n\nexport function stringRegex(regex: RegExp) {\n\treturn stringRegexValidator('s.string.regex', `expected ${regex}.test(expected) to be true`, regex);\n}\n\nexport function stringUuid({ version = 4, nullable = false }: StringUuidOptions = {}) {\n\tversion ??= '1-5';\n\tconst regex = new RegExp(\n\t\t`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${\n\t\t\tnullable ? '|00000000-0000-0000-0000-000000000000' : ''\n\t\t})$`,\n\t\t'i'\n\t);\n\tconst expected = `expected to match UUID${typeof version === 'number' ? `v${version}` : ` in range of ${version}`}`;\n\treturn stringRegexValidator('s.string.uuid', expected, regex);\n}\n","/**\n * [RFC-5322](https://datatracker.ietf.org/doc/html/rfc5322)\n * compliant {@link RegExp} to validate an email address\n *\n * @see https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression/201378#201378\n */\nconst accountRegex =\n\t/^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")$/;\n\n/**\n * Validates an email address string based on various checks:\n * - It must be a non nullish and non empty string\n * - It must include at least an `@` symbol`\n * - The account name may not exceed 64 characters\n * - The domain name may not exceed 255 characters\n * - The domain must include at least one `.` symbol\n * - Each part of the domain, split by `.` must not exceed 63 characters\n * - The email address must be [RFC-5322](https://datatracker.ietf.org/doc/html/rfc5322) compliant\n * @param email The email to validate\n * @returns `true` if the email is valid, `false` otherwise\n *\n * @remark Based on the following sources:\n * - `email-validator` by [manisharaan](https://github.com/manishsaraan) ([code](https://github.com/manishsaraan/email-validator/blob/master/index.js))\n * - [Comparing E-mail Address Validating Regular Expressions](http://fightingforalostcause.net/misc/2006/compare-email-regex.php)\n * - [Validating Email Addresses by Derrick Pallas](http://thedailywtf.com/Articles/Validating_Email_Addresses.aspx)\n * - [StackOverflow answer by bortzmeyer](http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/201378#201378)\n * - [The wikipedia page on Email addresses](https://en.wikipedia.org/wiki/Email_address)\n */\nexport function validateEmail(email: string): boolean {\n\t// 1. Non-nullish and non-empty string check.\n\t//\n\t// If a nullish or empty email was provided then do an early exit\n\tif (!email) return false;\n\n\t// Find the location of the @ symbol:\n\tconst atIndex = email.indexOf('@');\n\n\t// 2. @ presence check.\n\t//\n\t// If the email does not have the @ symbol, it's automatically invalid:\n\tif (atIndex === -1) return false;\n\n\t// 3. <account> maximum length check.\n\t//\n\t// From <account>@<domain>, if <account> exceeds 64 characters, then the\n\t// position of the @ symbol is 64 or greater. In this case, the email is\n\t// invalid:\n\tif (atIndex > 64) return false;\n\n\tconst domainIndex = atIndex + 1;\n\n\t// 7.1. Duplicated @ symbol check.\n\t//\n\t// If there's a second @ symbol, the email is automatically invalid:\n\tif (email.includes('@', domainIndex)) return false;\n\n\t// 4. <domain> maximum length check.\n\t//\n\t// From <account>@<domain>, if <domain> exceeds 255 characters, then it\n\t// means that the amount of characters between the start of <domain> and the\n\t// end of the string is separated by 255 or more characters.\n\tif (email.length - domainIndex > 255) return false;\n\n\t// Find the location of the . symbol in <domain>:\n\tlet dotIndex = email.indexOf('.', domainIndex);\n\n\t// 5. <domain> dot (.) symbol check.\n\t//\n\t// From <account>@<domain>, if <domain> does not contain a dot (.) symbol,\n\t// then it means the domain is invalid.\n\tif (dotIndex === -1) return false;\n\n\t// 6. <domain> parts length.\n\t//\n\t// Assign a temporary variable to store the start of the last read domain\n\t// part, this would be at the start of <domain>.\n\t//\n\t// For a <domain> part to be correct, it must have at most, 63 characters.\n\t// We repeat this step for every sub-section of <domain> contained within\n\t// dot (.) symbols.\n\t//\n\t// The following step is a more optimized version of the following code:\n\t//\n\t// ```javascript\n\t// domain.split('.').some((part) => part.length > 63);\n\t// ```\n\tlet lastDotIndex = domainIndex;\n\tdo {\n\t\tif (dotIndex - lastDotIndex > 63) return false;\n\n\t\tlastDotIndex = dotIndex + 1;\n\t} while ((dotIndex = email.indexOf('.', lastDotIndex)) !== -1);\n\n\t// The loop iterates from the first to the n - 1 part, this line checks for\n\t// the last (n) part:\n\tif (email.length - lastDotIndex > 63) return false;\n\n\t// 7.2. Character checks.\n\t//\n\t// From <account>@<domain>:\n\t// - Extract the <account> part by slicing the input from start to the @\n\t//   character. Validate afterwards.\n\t// - Extract the <domain> part by slicing the input from the start of\n\t//   <domain>. Validate afterwards.\n\t//\n\t// Note: we inline the variables so <domain> isn't created unless the\n\t//       <account> check passes.\n\treturn accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));\n}\n\nfunction validateEmailDomain(domain: string): boolean {\n\ttry {\n\t\treturn new URL(`http://${domain}`).hostname === domain;\n\t} catch {\n\t\treturn false;\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'node:util';\nimport { customInspectSymbolStackLess } from './BaseError';\nimport { BaseConstraintError, type ConstraintErrorNames } from './BaseConstraintError';\n\nexport class MultiplePossibilitiesConstraintError<T = unknown> extends BaseConstraintError<T> {\n\tpublic readonly expected: readonly string[];\n\n\tpublic constructor(constraint: ConstraintErrorNames, message: string, given: T, expected: readonly string[]) {\n\t\tsuper(constraint, message, given);\n\t\tthis.expected = expected;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tconstraint: this.constraint,\n\t\t\tgiven: this.given,\n\t\t\texpected: this.expected\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst constraint = options.stylize(this.constraint, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1 };\n\n\t\tconst verticalLine = options.stylize('|', 'undefined');\n\t\tconst padding = `\\n  ${verticalLine} `;\n\t\tconst given = inspect(this.given, newOptions).replaceAll('\\n', padding);\n\n\t\tconst header = `${options.stylize('MultiplePossibilitiesConstraintError', 'special')} > ${constraint}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\n\t\tconst expectedPadding = `\\n  ${verticalLine} - `;\n\t\tconst expectedBlock = `\\n  ${options.stylize('Expected any of the following:', 'string')}${expectedPadding}${this.expected\n\t\t\t.map((possible) => options.stylize(possible, 'boolean'))\n\t\t\t.join(expectedPadding)}`;\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${expectedBlock}\\n${givenBlock}`;\n\t}\n}\n","export function combinedErrorFn<P extends [...any], E extends Error>(...fns: ErrorFn<P, E>[]): ErrorFn<P, E> {\n\tswitch (fns.length) {\n\t\tcase 0:\n\t\t\treturn () => null;\n\t\tcase 1:\n\t\t\treturn fns[0];\n\t\tcase 2: {\n\t\t\tconst [fn0, fn1] = fns;\n\t\t\treturn (...params) => fn0(...params) || fn1(...params);\n\t\t}\n\t\tdefault: {\n\t\t\treturn (...params) => {\n\t\t\t\tfor (const fn of fns) {\n\t\t\t\t\tconst result = fn(...params);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport type ErrorFn<P extends [...any], E extends Error> = (...params: P) => E | null;\n","import { MultiplePossibilitiesConstraintError } from '../../lib/errors/MultiplePossibilitiesConstraintError';\nimport { combinedErrorFn, ErrorFn } from './common/combinedResultFn';\n\nexport type StringProtocol = `${string}:`;\n\nexport type StringDomain = `${string}.${string}`;\n\nexport interface UrlOptions {\n\tallowedProtocols?: StringProtocol[];\n\tallowedDomains?: StringDomain[];\n}\n\nexport function createUrlValidators(options?: UrlOptions) {\n\tconst fns: ErrorFn<[input: string, url: URL], MultiplePossibilitiesConstraintError<string>>[] = [];\n\n\tif (options?.allowedProtocols?.length) fns.push(allowedProtocolsFn(options.allowedProtocols));\n\tif (options?.allowedDomains?.length) fns.push(allowedDomainsFn(options.allowedDomains));\n\n\treturn combinedErrorFn(...fns);\n}\n\nfunction allowedProtocolsFn(allowedProtocols: StringProtocol[]) {\n\treturn (input: string, url: URL) =>\n\t\tallowedProtocols.includes(url.protocol as StringProtocol)\n\t\t\t? null\n\t\t\t: new MultiplePossibilitiesConstraintError('s.string.url', 'Invalid URL protocol', input, allowedProtocols);\n}\n\nfunction allowedDomainsFn(allowedDomains: StringDomain[]) {\n\treturn (input: string, url: URL) =>\n\t\tallowedDomains.includes(url.hostname as StringDomain)\n\t\t\t? null\n\t\t\t: new MultiplePossibilitiesConstraintError('s.string.url', 'Invalid URL domain', input, allowedDomains);\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport {\n\tstringEmail,\n\tstringIp,\n\tstringLengthEq,\n\tstringLengthGe,\n\tstringLengthGt,\n\tstringLengthLe,\n\tstringLengthLt,\n\tstringLengthNe,\n\tstringRegex,\n\tstringUrl,\n\tstringUuid,\n\tStringUuidOptions,\n\ttype UrlOptions\n} from '../constraints/StringConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class StringValidator<T extends string> extends BaseValidator<T> {\n\tpublic lengthLt(length: number): this {\n\t\treturn this.addConstraint(stringLengthLt(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthLe(length: number): this {\n\t\treturn this.addConstraint(stringLengthLe(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthGt(length: number): this {\n\t\treturn this.addConstraint(stringLengthGt(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthGe(length: number): this {\n\t\treturn this.addConstraint(stringLengthGe(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthEq(length: number): this {\n\t\treturn this.addConstraint(stringLengthEq(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthNe(length: number): this {\n\t\treturn this.addConstraint(stringLengthNe(length) as IConstraint<T>);\n\t}\n\n\tpublic get email(): this {\n\t\treturn this.addConstraint(stringEmail() as IConstraint<T>);\n\t}\n\n\tpublic url(options?: UrlOptions): this {\n\t\treturn this.addConstraint(stringUrl(options) as IConstraint<T>);\n\t}\n\n\tpublic uuid(options?: StringUuidOptions): this {\n\t\treturn this.addConstraint(stringUuid(options) as IConstraint<T>);\n\t}\n\n\tpublic regex(regex: RegExp): this {\n\t\treturn this.addConstraint(stringRegex(regex) as IConstraint<T>);\n\t}\n\n\tpublic get ipv4(): this {\n\t\treturn this.ip(4);\n\t}\n\n\tpublic get ipv6(): this {\n\t\treturn this.ip(6);\n\t}\n\n\tpublic ip(version?: 4 | 6): this {\n\t\treturn this.addConstraint(stringIp(version) as IConstraint<T>);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'string' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.string', 'Expected a string primitive', value));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class TupleValidator<T extends any[]> extends BaseValidator<[...T]> {\n\tprivate readonly validators: BaseValidator<[...T]>[] = [];\n\n\tpublic constructor(validators: BaseValidator<[...T]>[], constraints: readonly IConstraint<[...T]>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validators = validators;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validators, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<[...T], ValidationError | CombinedPropertyError> {\n\t\tif (!Array.isArray(values)) {\n\t\t\treturn Result.err(new ValidationError('s.tuple(T)', 'Expected an array', values));\n\t\t}\n\n\t\tif (values.length !== this.validators.length) {\n\t\t\treturn Result.err(new ValidationError('s.tuple(T)', `Expected an array of length ${this.validators.length}`, values));\n\t\t}\n\n\t\tconst errors: [number, BaseError][] = [];\n\t\tconst transformed: T = [] as unknown as T;\n\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst result = this.validators[i].run(values[i]);\n\t\t\tif (result.isOk()) transformed.push(result.value);\n\t\t\telse errors.push([i, result.error!]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedError } from '../lib/errors/CombinedError';\nimport type { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator, LiteralValidator, NullishValidator } from './imports';\n\nexport class UnionValidator<T> extends BaseValidator<T> {\n\tprivate validators: readonly BaseValidator<T>[];\n\n\tpublic constructor(validators: readonly BaseValidator<T>[], constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validators = validators;\n\t}\n\n\tpublic override get optional(): UnionValidator<T | undefined> {\n\t\tif (this.validators.length === 0) return new UnionValidator<T | undefined>([new LiteralValidator(undefined)], this.constraints);\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\t// If already optional, return a clone:\n\t\t\tif (validator.expected === undefined) return this.clone();\n\n\t\t\t// If it's nullable, convert the nullable validator into a nullish validator to optimize `null | undefined`:\n\t\t\tif (validator.expected === null) {\n\t\t\t\treturn new UnionValidator<T | null | undefined>(\n\t\t\t\t\t[new NullishValidator(), ...this.validators.slice(1)],\n\t\t\t\t\tthis.constraints\n\t\t\t\t) as UnionValidator<T | undefined>;\n\t\t\t}\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t// If it's already nullish (which validates optional), return a clone:\n\t\t\treturn this.clone();\n\t\t}\n\n\t\treturn new UnionValidator([new LiteralValidator(undefined), ...this.validators]);\n\t}\n\n\tpublic override get nullable(): UnionValidator<T | null> {\n\t\tif (this.validators.length === 0) return new UnionValidator<T | null>([new LiteralValidator(null)], this.constraints);\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\t// If already nullable, return a clone:\n\t\t\tif (validator.expected === null) return this.clone();\n\n\t\t\t// If it's optional, convert the optional validator into a nullish validator to optimize `null | undefined`:\n\t\t\tif (validator.expected === undefined) {\n\t\t\t\treturn new UnionValidator<T | null | undefined>(\n\t\t\t\t\t[new NullishValidator(), ...this.validators.slice(1)],\n\t\t\t\t\tthis.constraints\n\t\t\t\t) as UnionValidator<T | null>;\n\t\t\t}\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t// If it's already nullish (which validates nullable), return a clone:\n\t\t\treturn this.clone();\n\t\t}\n\n\t\treturn new UnionValidator([new LiteralValidator(null), ...this.validators]);\n\t}\n\n\tpublic override get nullish(): UnionValidator<T | null | undefined> {\n\t\tif (this.validators.length === 0) return new UnionValidator<T | null | undefined>([new NullishValidator()], this.constraints);\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\t// If already nullable or optional, promote the union to nullish:\n\t\t\tif (validator.expected === null || validator.expected === undefined) {\n\t\t\t\treturn new UnionValidator<T | null | undefined>([new NullishValidator(), ...this.validators.slice(1)], this.constraints);\n\t\t\t}\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t// If it's already nullish, return a clone:\n\t\t\treturn this.clone();\n\t\t}\n\n\t\treturn new UnionValidator<T | null | undefined>([new NullishValidator(), ...this.validators]);\n\t}\n\n\tpublic override or<O>(...predicates: readonly BaseValidator<O>[]): UnionValidator<T | O> {\n\t\treturn new UnionValidator<T | O>([...this.validators, ...predicates]);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validators, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError | CombinedError> {\n\t\tconst errors: BaseError[] = [];\n\n\t\tfor (const validator of this.validators) {\n\t\t\tconst result = validator.run(value);\n\t\t\tif (result.isOk()) return result as Result<T, CombinedError>;\n\t\t\terrors.push(result.error!);\n\t\t}\n\n\t\treturn Result.err(new CombinedError(errors));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class MapValidator<K, V> extends BaseValidator<Map<K, V>> {\n\tprivate readonly keyValidator: BaseValidator<K>;\n\tprivate readonly valueValidator: BaseValidator<V>;\n\n\tpublic constructor(keyValidator: BaseValidator<K>, valueValidator: BaseValidator<V>, constraints: readonly IConstraint<Map<K, V>>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.keyValidator = keyValidator;\n\t\tthis.valueValidator = valueValidator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<Map<K, V>, ValidationError | CombinedPropertyError> {\n\t\tif (!(value instanceof Map)) {\n\t\t\treturn Result.err(new ValidationError('s.map(K, V)', 'Expected a map', value));\n\t\t}\n\n\t\tconst errors: [string, BaseError][] = [];\n\t\tconst transformed = new Map<K, V>();\n\n\t\tfor (const [key, val] of value.entries()) {\n\t\t\tconst keyResult = this.keyValidator.run(key);\n\t\t\tconst valueResult = this.valueValidator.run(val);\n\t\t\tconst { length } = errors;\n\t\t\tif (keyResult.isErr()) errors.push([key, keyResult.error]);\n\t\t\tif (valueResult.isErr()) errors.push([key, valueResult.error]);\n\t\t\tif (errors.length === length) transformed.set(keyResult.value!, valueResult.value!);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","// https://github.com/microsoft/TypeScript/issues/37663\ntype Fn = (...args: unknown[]) => unknown;\n\nexport function getValue<T, U = T extends Fn ? ReturnType<T> : T>(valueOrFn: T): U {\n\treturn typeof valueOrFn === 'function' ? valueOrFn() : valueOrFn;\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { Result } from '../lib/Result';\nimport type { ValidatorError } from './BaseValidator';\nimport { BaseValidator } from './imports';\nimport { getValue } from './util/getValue';\n\nexport class DefaultValidator<T> extends BaseValidator<T> {\n\tprivate readonly validator: BaseValidator<T>;\n\tprivate defaultValue: T | (() => T);\n\n\tpublic constructor(validator: BaseValidator<T>, value: T | (() => T), constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t\tthis.defaultValue = value;\n\t}\n\n\tpublic override default(value: Exclude<T, undefined> | (() => Exclude<T, undefined>)): DefaultValidator<Exclude<T, undefined>> {\n\t\tconst clone = this.clone() as unknown as DefaultValidator<Exclude<T, undefined>>;\n\t\tclone.defaultValue = value;\n\t\treturn clone;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidatorError> {\n\t\treturn typeof value === 'undefined' //\n\t\t\t? Result.ok(getValue(this.defaultValue))\n\t\t\t: this.validator['handle'](value); // eslint-disable-line @typescript-eslint/dot-notation\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);\n\t}\n}\n","import type { InspectOptionsStylized } from 'node:util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class UnknownEnumValueError extends BaseError {\n\tpublic readonly value: string | number;\n\tpublic readonly enumKeys: string[];\n\tpublic readonly enumMappings: Map<string | number, string | number>;\n\n\tpublic constructor(value: string | number, keys: string[], enumMappings: Map<string | number, string | number>) {\n\t\tsuper('Expected the value to be one of the following enum values:');\n\n\t\tthis.value = value;\n\t\tthis.enumKeys = keys;\n\t\tthis.enumMappings = enumMappings;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvalue: this.value,\n\t\t\tenumKeys: this.enumKeys,\n\t\t\tenumMappings: [...this.enumMappings.entries()]\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst value = options.stylize(this.value.toString(), 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[UnknownEnumValueError: ${value}]`, 'special');\n\t\t}\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst pairs = this.enumKeys\n\t\t\t.map((key) => {\n\t\t\t\tconst enumValue = this.enumMappings.get(key)!;\n\t\t\t\treturn `${options.stylize(key, 'string')} or ${options.stylize(\n\t\t\t\t\tenumValue.toString(),\n\t\t\t\t\ttypeof enumValue === 'number' ? 'number' : 'string'\n\t\t\t\t)}`;\n\t\t\t})\n\t\t\t.join(padding);\n\n\t\tconst header = `${options.stylize('UnknownEnumValueError', 'special')} > ${value}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst pairsBlock = `${padding}${pairs}`;\n\t\treturn `${header}\\n  ${message}\\n${pairsBlock}`;\n\t}\n}\n","import { UnknownEnumValueError } from '../lib/errors/UnknownEnumValueError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NativeEnumValidator<T extends NativeEnumLike> extends BaseValidator<T[keyof T]> {\n\tpublic readonly enumShape: T;\n\tpublic readonly hasNumericElements: boolean = false;\n\tprivate readonly enumKeys: string[];\n\tprivate readonly enumMapping = new Map<string | number, T[keyof T]>();\n\n\tpublic constructor(enumShape: T) {\n\t\tsuper();\n\t\tthis.enumShape = enumShape;\n\n\t\tthis.enumKeys = Object.keys(enumShape).filter((key) => {\n\t\t\treturn typeof enumShape[enumShape[key]] !== 'number';\n\t\t});\n\n\t\tfor (const key of this.enumKeys) {\n\t\t\tconst enumValue = enumShape[key] as T[keyof T];\n\n\t\t\tthis.enumMapping.set(key, enumValue);\n\t\t\tthis.enumMapping.set(enumValue, enumValue);\n\n\t\t\tif (typeof enumValue === 'number') {\n\t\t\t\tthis.hasNumericElements = true;\n\t\t\t\tthis.enumMapping.set(`${enumValue}`, enumValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected override handle(value: unknown): Result<T[keyof T], ValidationError | UnknownEnumValueError> {\n\t\tconst typeOfValue = typeof value;\n\n\t\tif (typeOfValue === 'number') {\n\t\t\tif (!this.hasNumericElements) {\n\t\t\t\treturn Result.err(new ValidationError('s.nativeEnum(T)', 'Expected the value to be a string', value));\n\t\t\t}\n\t\t} else if (typeOfValue !== 'string') {\n\t\t\t// typeOfValue !== 'number' is implied here\n\t\t\treturn Result.err(new ValidationError('s.nativeEnum(T)', 'Expected the value to be a string or number', value));\n\t\t}\n\n\t\tconst casted = value as string | number;\n\n\t\tconst possibleEnumValue = this.enumMapping.get(casted);\n\n\t\treturn typeof possibleEnumValue === 'undefined'\n\t\t\t? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping))\n\t\t\t: Result.ok(possibleEnumValue);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.enumShape]);\n\t}\n}\n\nexport interface NativeEnumLike {\n\t[key: string]: string | number;\n\t[key: number]: string;\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { Comparator, eq, ge, gt, le, lt, ne } from './util/operators';\nimport type { TypedArray } from './util/typedArray';\n\nexport type TypedArrayConstraintName = `s.typedArray(T).${'byteLength' | 'length'}${\n\t| 'Lt'\n\t| 'Le'\n\t| 'Gt'\n\t| 'Ge'\n\t| 'Eq'\n\t| 'Ne'\n\t| 'Range'\n\t| 'RangeInclusive'\n\t| 'RangeExclusive'}`;\n\nfunction typedArrayByteLengthComparator<T extends TypedArray>(\n\tcomparator: Comparator,\n\tname: TypedArrayConstraintName,\n\texpected: string,\n\tlength: number\n): IConstraint<T> {\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn comparator(input.byteLength, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Typed Array byte length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayByteLengthLt<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength < ${value}`;\n\treturn typedArrayByteLengthComparator(lt, 's.typedArray(T).byteLengthLt', expected, value);\n}\n\nexport function typedArrayByteLengthLe<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength <= ${value}`;\n\treturn typedArrayByteLengthComparator(le, 's.typedArray(T).byteLengthLe', expected, value);\n}\n\nexport function typedArrayByteLengthGt<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength > ${value}`;\n\treturn typedArrayByteLengthComparator(gt, 's.typedArray(T).byteLengthGt', expected, value);\n}\n\nexport function typedArrayByteLengthGe<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength >= ${value}`;\n\treturn typedArrayByteLengthComparator(ge, 's.typedArray(T).byteLengthGe', expected, value);\n}\n\nexport function typedArrayByteLengthEq<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength === ${value}`;\n\treturn typedArrayByteLengthComparator(eq, 's.typedArray(T).byteLengthEq', expected, value);\n}\n\nexport function typedArrayByteLengthNe<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength !== ${value}`;\n\treturn typedArrayByteLengthComparator(ne, 's.typedArray(T).byteLengthNe', expected, value);\n}\n\nexport function typedArrayByteLengthRange<T extends TypedArray>(start: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.byteLength >= start && input.byteLength < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).byteLengthRange', 'Invalid Typed Array byte length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayByteLengthRangeInclusive<T extends TypedArray>(start: number, end: number) {\n\tconst expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.byteLength >= start && input.byteLength <= end //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(\n\t\t\t\t\t\tnew ExpectedConstraintError('s.typedArray(T).byteLengthRangeInclusive', 'Invalid Typed Array byte length', input, expected)\n\t\t\t\t  );\n\t\t}\n\t};\n}\n\nexport function typedArrayByteLengthRangeExclusive<T extends TypedArray>(startAfter: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.byteLength > startAfter && input.byteLength < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(\n\t\t\t\t\t\tnew ExpectedConstraintError('s.typedArray(T).byteLengthRangeExclusive', 'Invalid Typed Array byte length', input, expected)\n\t\t\t\t  );\n\t\t}\n\t};\n}\n\nfunction typedArrayLengthComparator<T extends TypedArray>(\n\tcomparator: Comparator,\n\tname: TypedArrayConstraintName,\n\texpected: string,\n\tlength: number\n): IConstraint<T> {\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn comparator(input.length, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayLengthLt<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length < ${value}`;\n\treturn typedArrayLengthComparator(lt, 's.typedArray(T).lengthLt', expected, value);\n}\n\nexport function typedArrayLengthLe<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length <= ${value}`;\n\treturn typedArrayLengthComparator(le, 's.typedArray(T).lengthLe', expected, value);\n}\n\nexport function typedArrayLengthGt<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length > ${value}`;\n\treturn typedArrayLengthComparator(gt, 's.typedArray(T).lengthGt', expected, value);\n}\n\nexport function typedArrayLengthGe<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length >= ${value}`;\n\treturn typedArrayLengthComparator(ge, 's.typedArray(T).lengthGe', expected, value);\n}\n\nexport function typedArrayLengthEq<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length === ${value}`;\n\treturn typedArrayLengthComparator(eq, 's.typedArray(T).lengthEq', expected, value);\n}\n\nexport function typedArrayLengthNe<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length !== ${value}`;\n\treturn typedArrayLengthComparator(ne, 's.typedArray(T).lengthNe', expected, value);\n}\n\nexport function typedArrayLengthRange<T extends TypedArray>(start: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.length >= ${start} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.length >= start && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).lengthRange', 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayLengthRangeInclusive<T extends TypedArray>(start: number, end: number): IConstraint<T> {\n\tconst expected = `expected.length >= ${start} && expected.length <= ${end}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.length >= start && input.length <= end //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).lengthRangeInclusive', 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayLengthRangeExclusive<T extends TypedArray>(startAfter: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.length > startAfter && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).lengthRangeExclusive', 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n","export type TypedArray =\n\t| Int8Array\n\t| Uint8Array\n\t| Uint8ClampedArray\n\t| Int16Array\n\t| Uint16Array\n\t| Int32Array\n\t| Uint32Array\n\t| Float32Array\n\t| Float64Array\n\t| BigInt64Array\n\t| BigUint64Array;\n\nexport const TypedArrays = {\n\tInt8Array: (x: unknown): x is Int8Array => x instanceof Int8Array,\n\tUint8Array: (x: unknown): x is Uint8Array => x instanceof Uint8Array,\n\tUint8ClampedArray: (x: unknown): x is Uint8ClampedArray => x instanceof Uint8ClampedArray,\n\tInt16Array: (x: unknown): x is Int16Array => x instanceof Int16Array,\n\tUint16Array: (x: unknown): x is Uint16Array => x instanceof Uint16Array,\n\tInt32Array: (x: unknown): x is Int32Array => x instanceof Int32Array,\n\tUint32Array: (x: unknown): x is Uint32Array => x instanceof Uint32Array,\n\tFloat32Array: (x: unknown): x is Float32Array => x instanceof Float32Array,\n\tFloat64Array: (x: unknown): x is Float64Array => x instanceof Float64Array,\n\tBigInt64Array: (x: unknown): x is BigInt64Array => x instanceof BigInt64Array,\n\tBigUint64Array: (x: unknown): x is BigUint64Array => x instanceof BigUint64Array,\n\tTypedArray: (x: unknown): x is TypedArray => ArrayBuffer.isView(x) && !(x instanceof DataView)\n} as const;\n\nexport type TypedArrayName = keyof typeof TypedArrays;\n","const vowels = ['a', 'e', 'i', 'o', 'u'];\n\nexport const aOrAn = (word: string) => {\n\treturn `${vowels.includes(word[0].toLowerCase()) ? 'an' : 'a'} ${word}`;\n};\n","import {\n\ttypedArrayByteLengthEq,\n\ttypedArrayByteLengthGe,\n\ttypedArrayByteLengthGt,\n\ttypedArrayByteLengthLe,\n\ttypedArrayByteLengthLt,\n\ttypedArrayByteLengthNe,\n\ttypedArrayByteLengthRange,\n\ttypedArrayByteLengthRangeExclusive,\n\ttypedArrayByteLengthRangeInclusive,\n\ttypedArrayLengthEq,\n\ttypedArrayLengthGe,\n\ttypedArrayLengthGt,\n\ttypedArrayLengthLe,\n\ttypedArrayLengthLt,\n\ttypedArrayLengthNe,\n\ttypedArrayLengthRange,\n\ttypedArrayLengthRangeExclusive,\n\ttypedArrayLengthRangeInclusive\n} from '../constraints/TypedArrayLengthConstraints';\nimport type { IConstraint } from '../constraints/base/IConstraint';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\nimport { TypedArray, TypedArrayName, TypedArrays } from '../constraints/util/typedArray';\nimport { aOrAn } from '../constraints/util/common/vowels';\n\nexport class TypedArrayValidator<T extends TypedArray> extends BaseValidator<T> {\n\tprivate readonly type: TypedArrayName;\n\n\tpublic constructor(type: TypedArrayName, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.type = type;\n\t}\n\n\tpublic byteLengthLt(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthLt(length));\n\t}\n\n\tpublic byteLengthLe(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthLe(length));\n\t}\n\n\tpublic byteLengthGt(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthGt(length));\n\t}\n\n\tpublic byteLengthGe(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthGe(length));\n\t}\n\n\tpublic byteLengthEq(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthEq(length));\n\t}\n\n\tpublic byteLengthNe(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthNe(length));\n\t}\n\n\tpublic byteLengthRange(start: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthRange(start, endBefore));\n\t}\n\n\tpublic byteLengthRangeInclusive(startAt: number, endAt: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt) as IConstraint<T>);\n\t}\n\n\tpublic byteLengthRangeExclusive(startAfter: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));\n\t}\n\n\tpublic lengthLt(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthLt(length));\n\t}\n\n\tpublic lengthLe(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthLe(length));\n\t}\n\n\tpublic lengthGt(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthGt(length));\n\t}\n\n\tpublic lengthGe(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthGe(length));\n\t}\n\n\tpublic lengthEq(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthEq(length));\n\t}\n\n\tpublic lengthNe(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthNe(length));\n\t}\n\n\tpublic lengthRange(start: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayLengthRange(start, endBefore));\n\t}\n\n\tpublic lengthRangeInclusive(startAt: number, endAt: number) {\n\t\treturn this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));\n\t}\n\n\tpublic lengthRangeExclusive(startAfter: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.type, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn TypedArrays[this.type](value)\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.typedArray', `Expected ${aOrAn(this.type)}`, value));\n\t}\n}\n","import type { TypedArray, TypedArrayName } from '../constraints/util/typedArray';\nimport {\n\tArrayValidator,\n\tBaseValidator,\n\tBigIntValidator,\n\tBooleanValidator,\n\tDateValidator,\n\tInstanceValidator,\n\tLiteralValidator,\n\tMapValidator,\n\tNeverValidator,\n\tNullishValidator,\n\tNumberValidator,\n\tObjectValidator,\n\tPassthroughValidator,\n\tRecordValidator,\n\tSetValidator,\n\tStringValidator,\n\tTupleValidator,\n\tUnionValidator\n} from '../validators/imports';\nimport { NativeEnumLike, NativeEnumValidator } from '../validators/NativeEnumValidator';\nimport { TypedArrayValidator } from '../validators/TypedArrayValidator';\nimport type { Constructor, MappedObjectValidator } from './util-types';\n\nexport class Shapes {\n\tpublic get string() {\n\t\treturn new StringValidator();\n\t}\n\n\tpublic get number() {\n\t\treturn new NumberValidator();\n\t}\n\n\tpublic get bigint() {\n\t\treturn new BigIntValidator();\n\t}\n\n\tpublic get boolean() {\n\t\treturn new BooleanValidator();\n\t}\n\n\tpublic get date() {\n\t\treturn new DateValidator();\n\t}\n\n\tpublic object<T>(shape: MappedObjectValidator<T>) {\n\t\treturn new ObjectValidator(shape);\n\t}\n\n\tpublic get undefined() {\n\t\treturn this.literal(undefined);\n\t}\n\n\tpublic get null() {\n\t\treturn this.literal(null);\n\t}\n\n\tpublic get nullish() {\n\t\treturn new NullishValidator();\n\t}\n\n\tpublic get any() {\n\t\treturn new PassthroughValidator<any>();\n\t}\n\n\tpublic get unknown() {\n\t\treturn new PassthroughValidator<unknown>();\n\t}\n\n\tpublic get never() {\n\t\treturn new NeverValidator();\n\t}\n\n\tpublic enum<T>(...values: readonly T[]) {\n\t\treturn this.union(...values.map((value) => this.literal(value)));\n\t}\n\n\tpublic nativeEnum<T extends NativeEnumLike>(enumShape: T): NativeEnumValidator<T> {\n\t\treturn new NativeEnumValidator(enumShape);\n\t}\n\n\tpublic literal<T>(value: T): BaseValidator<T> {\n\t\tif (value instanceof Date) return this.date.eq(value) as unknown as BaseValidator<T>;\n\t\treturn new LiteralValidator(value);\n\t}\n\n\tpublic instance<T>(expected: Constructor<T>): InstanceValidator<T> {\n\t\treturn new InstanceValidator(expected);\n\t}\n\n\tpublic union<T extends [...BaseValidator<any>[]]>(...validators: [...T]): UnionValidator<Unwrap<T[number]>> {\n\t\treturn new UnionValidator(validators);\n\t}\n\n\tpublic array<T>(validator: BaseValidator<T>) {\n\t\treturn new ArrayValidator(validator);\n\t}\n\n\tpublic typedArray<T extends TypedArray>(type: TypedArrayName = 'TypedArray') {\n\t\treturn new TypedArrayValidator<T>(type);\n\t}\n\n\tpublic get int8Array() {\n\t\treturn this.typedArray<Int8Array>('Int8Array');\n\t}\n\n\tpublic get uint8Array() {\n\t\treturn this.typedArray<Uint8Array>('Uint8Array');\n\t}\n\n\tpublic get uint8ClampedArray() {\n\t\treturn this.typedArray<Uint8ClampedArray>('Uint8ClampedArray');\n\t}\n\n\tpublic get int16Array() {\n\t\treturn this.typedArray<Int16Array>('Int16Array');\n\t}\n\n\tpublic get uint16Array() {\n\t\treturn this.typedArray<Uint16Array>('Uint16Array');\n\t}\n\n\tpublic get int32Array() {\n\t\treturn this.typedArray<Int32Array>('Int32Array');\n\t}\n\n\tpublic get uint32Array() {\n\t\treturn this.typedArray<Uint32Array>('Uint32Array');\n\t}\n\n\tpublic get float32Array() {\n\t\treturn this.typedArray<Float32Array>('Float32Array');\n\t}\n\n\tpublic get float64Array() {\n\t\treturn this.typedArray<Float64Array>('Float64Array');\n\t}\n\n\tpublic get bigInt64Array() {\n\t\treturn this.typedArray<BigInt64Array>('BigInt64Array');\n\t}\n\n\tpublic get bigUint64Array() {\n\t\treturn this.typedArray<BigUint64Array>('BigUint64Array');\n\t}\n\n\tpublic tuple<T extends [...BaseValidator<any>[]]>(validators: [...T]): TupleValidator<UnwrapTuple<T>> {\n\t\treturn new TupleValidator(validators);\n\t}\n\n\tpublic set<T>(validator: BaseValidator<T>) {\n\t\treturn new SetValidator(validator);\n\t}\n\n\tpublic record<T>(validator: BaseValidator<T>) {\n\t\treturn new RecordValidator(validator);\n\t}\n\n\tpublic map<T, U>(keyValidator: BaseValidator<T>, valueValidator: BaseValidator<U>) {\n\t\treturn new MapValidator(keyValidator, valueValidator);\n\t}\n}\n\nexport type UnwrapTuple<T extends [...any[]]> = T extends [infer Head, ...infer Tail] ? [Unwrap<Head>, ...UnwrapTuple<Tail>] : [];\nexport type Unwrap<T> = T extends BaseValidator<infer V> ? V : never;\n"],"mappings":"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","names":[]}